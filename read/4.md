# 객체란 무엇인가, 클래스란 무엇인가
![Object](/img/object.png)

객체란, 변수들과 참고 자료들로 이뤄진 소프트웨어 덩어리.
객체는 자기만의 정보를 나타내는 변수(instance variable)와 이를 가지고 어떠한 작업을 하는 함수(instance method)들로 둘러싸고 있다.

이 인스턴스 변수들은 그림과 같이 외부로부터 보호된다. 인스턴스 변수 값을 바꾸려면 인스턴스 함수를 통해서만 가능한 것이다. (예외도 있는 것 같음)
이처럼 외부에서 직접 인스턴스 변수의 값을 바꿀 수 없고 항상 인스턴스 메소드를 통해서 간접적으로 조절하는 것을 **캡슐화(Encapsulation)**라고 부른다.

![Class](/img/class.png)

클래스는 객체의 '설계도'이다. 그림과 같이 객체는 안의 내용이 차 있지 않고 빈 껍질과 같다.

```c++
#include <iostream>

class Animal
{
	private:
		int food;
		int weight;
	
	public:
		void set_animal(int _food, int _weight)
		{
			food = _food;
			weight = _weight;
		}
		void increase_food(int inc)
		{
			food += inc;
			weight += (inc / 3);
		}
		void view_stat()
		{
			std::cout << "이 동물의 food: " << food << std::endl;
			std::cout << "이 동물의 weight: " << weight << std::endl;
		}
};

int main(void)
{
	Animal animal;
	animal.set_animal(100, 50);
	animal.increase_food(30);
	animal.view_stat();
	return (0);
}
```
```text
<result>
이 동물의 food: 130
이 동물의 weight: 60
```

`Animal` 클래스에는 멤버 변수(member variable)와 멤버 함수(member function)이 있다. 이 클래스로부터 생성된 객체에서는 각각 인스턴스 변수와 인스턴수 함수로 불린다.

# 접근 지시자 (public, private)
`private`과 `public`을 접근 지시자라고 한다. `private`인 모든 것들은 자기 객체 안에서만 접근 가능하다. 반대로 `public`은 객체 밖에서도 접근이 가능하다. 

# 오버로딩 (function overloading)
```c++
#include <iostream>

void print(int x) { std::cout << "int: " << x << std::endl; }
void print(char x) { std::cout << "char: " << x << std::endl; }
void print(double x) { std::cout << "double: " << x << std::endl; }

int main(void)
{
	int a = 1;
	char b = 'c';
	double c = 3.2f;

	print(a);
	print(b);
	print(c);

	return (0);
}
```
```text
<result>
int: 1
char: c
double: 3.2
```
C++에서는 C에서와 달리 같은 이름을 가진 함수가 여러개 존재한다. 구분은 함수를 호출하였을 때 사용하는 인자로 구분을 한다. C++에서는 컴파일러가 알아서 적합한 인자를 가지는 함수를 찾아서 호출한다.

C++ 컴파일러에서 함수를 오버로딩하는 과정은 다음과 같다.

먼저 자신과 타입이 같은 함수를 찾는다. 없다면, 형변환을 통해서 찾는다. 이때 같은 단계에서 두 개 이상이 일치하는 경우 모호하다 (ambiguous)라고 판단하고 오류를 뱉는다.

# 생성자 (constructor)
__생성 후 초기화__를 도와준다.
생성자는 다음과 같은 형태로 정의한다.
```text
클래스 이름 (인자) {}
(객체를 초기화하기 때문에 리턴값이 없다.)
```

```c++
Date day(2011, 3, 1);
Date day = Date(2011, 3, 1);
```
`Date`클래스의 `day` 객체를 만들면서 생성자 `Date(int year, int month, int day)`를 호출하라는 의미이다. 위는 암시적 방법, 아래는 명시적 방법.

# 디폴트 생성자 (default constructor)

```c++
int main(void)
{
	Date day = Date();
	Date day2;
	
	Date day3(); // dafault constructor를 사용하여 초기화하는 것이 아니라 리턴값이 `Date`이고 인자가 없는 함수  `day3`를 정의하게 된 것이다.

	return (0);
}
```

생성자를 정의하지 않았을 때 컴파일러는 자동으로 디폴트 생성자를 추가한다. 생성자를 정의한다면 컴파일러는 디폴트 생성자를 자동으로 추가해주지 않는다. 추가적으로 디폴트 생성자를 직접 정의할 수도 있다.

`day`와 `day2` 둘 다 dafault constructor를 이용하여 객체를 추가하게 된다.

# 생성자 오버로딩

생성자 역시 함수이기 때문에 오버로딩이 가능하다.

# 복사 생성자 (copy constructor) - 깊은 복사와 얕은 복사

# 소멸자 (destructor)

### reference
[씹어먹는 C++ - <4 - 1. 이 세상은 객체로 이루어져 있다>](https://modoocode.com/172)