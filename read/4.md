# 객체란 무엇인가, 클래스란 무엇인가
![Object](/img/object.png)

객체란, 변수들과 참고 자료들로 이뤄진 소프트웨어 덩어리.
객체는 자기만의 정보를 나타내는 변수(instance variable)와 이를 가지고 어떠한 작업을 하는 함수(instance method)들로 둘러싸고 있다.

이 인스턴스 변수들은 그림과 같이 외부로부터 보호된다. 인스턴스 변수 값을 바꾸려면 인스턴스 함수를 통해서만 가능한 것이다. (예외도 있는 것 같음)
이처럼 외부에서 직접 인스턴스 변수의 값을 바꿀 수 없고 항상 인스턴스 메소드를 통해서 간접적으로 조절하는 것을 **캡슐화(Encapsulation)**라고 부른다.

![Class](/img/class.png)

클래스는 객체의 '설계도'이다. 그림과 같이 객체는 안의 내용이 차 있지 않고 빈 껍질과 같다.

```c++
#include <iostream>

class Animal
{
	private:
		int food;
		int weight;
	
	public:
		void set_animal(int _food, int _weight)
		{
			food = _food;
			weight = _weight;
		}
		void increase_food(int inc)
		{
			food += inc;
			weight += (inc / 3);
		}
		void view_stat()
		{
			std::cout << "이 동물의 food: " << food << std::endl;
			std::cout << "이 동물의 weight: " << weight << std::endl;
		}
};

int main(void)
{
	Animal animal;
	animal.set_animal(100, 50);
	animal.increase_food(30);
	animal.view_stat();
	return (0);
}
```
```text
<result>
이 동물의 food: 130
이 동물의 weight: 60
```

`Animal` 클래스에는 멤버 변수(member variable)와 멤버 함수(member function)이 있다. 이 클래스로부터 생성된 객체에서는 각각 인스턴스 변수와 인스턴수 함수로 불린다.

# 접근 지시자 (public, private)
`private`과 `public`을 접근 지시자라고 한다. `private`인 모든 것들은 자기 객체 안에서만 접근 가능하다. 반대로 `public`은 객체 밖에서도 접근이 가능하다. 

# 오버로딩 (function overloading)
```c++
#include <iostream>

void print(int x) { std::cout << "int: " << x << std::endl; }
void print(char x) { std::cout << "char: " << x << std::endl; }
void print(double x) { std::cout << "double: " << x << std::endl; }

int main(void)
{
	int a = 1;
	char b = 'c';
	double c = 3.2f;

	print(a);
	print(b);
	print(c);

	return (0);
}
```
```text
<result>
int: 1
char: c
double: 3.2
```
C++에서는 C에서와 달리 같은 이름을 가진 함수가 여러개 존재한다. 구분은 함수를 호출하였을 때 사용하는 인자로 구분을 한다. C++에서는 컴파일러가 알아서 적합한 인자를 가지는 함수를 찾아서 호출한다.

C++ 컴파일러에서 함수를 오버로딩하는 과정은 다음과 같다.

먼저 자신과 타입이 같은 함수를 찾는다. 없다면, 형변환을 통해서 찾는다. 이때 같은 단계에서 두 개 이상이 일치하는 경우 모호하다 (ambiguous)라고 판단하고 오류를 뱉는다.

# 생성자 (constructor)
__생성 후 초기화__를 도와준다.
생성자는 다음과 같은 형태로 정의한다.
```text
클래스 이름 (인자) {}
(객체를 초기화하기 때문에 리턴값이 없다.)
```

```c++
Date day(2011, 3, 1);
Date day = Date(2011, 3, 1);
```
`Date`클래스의 `day` 객체를 만들면서 생성자 `Date(int year, int month, int day)`를 호출하라는 의미이다. 위는 암시적 방법, 아래는 명시적 방법.

# 디폴트 생성자 (default constructor)

```c++
int main(void)
{
	Date day = Date();
	Date day2;
	
	Date day3(); // dafault constructor를 사용하여 초기화하는 것이 아니라 리턴값이 `Date`이고 인자가 없는 함수  `day3`를 정의하게 된 것이다.

	return (0);
}
```

생성자를 정의하지 않았을 때 컴파일러는 자동으로 디폴트 생성자를 추가한다. 생성자를 정의한다면 컴파일러는 디폴트 생성자를 자동으로 추가해주지 않는다. 추가적으로 디폴트 생성자를 직접 정의할 수도 있다.

`day`와 `day2` 둘 다 dafault constructor를 이용하여 객체를 추가하게 된다.

# 생성자 오버로딩

생성자 역시 함수이기 때문에 오버로딩이 가능하다.

# 복사 생성자 (copy constructor) - 깊은 복사와 얕은 복사
```c++
/* 포토캐논 */
#include <iostream>
#include <string.h>

class Photon_Cannon
{
	int hp, shield;
	int coord_x, coord_y;
	int damage;

	public:
		Photon_Cannon(int x, int y);
		Photon_Cannon(const Photon_Cannon& pc);

		void show_status();
};

Photon_Cannon::Photon_Cannon(const Photon_Cannon& pc)
{
	std::cout << "복사 생성자 호출 !" << std::endl;
	hp = pc.hp;
	shield = pc.shield;
	coord_x = pc.coord_x;
	coord_y = pc.coord_y;
	damage = pc.damage;
}
Photon_Cannon::Photon_Cannon(int x, int y)
{
	std::cout << "생성자 호출!" << std::endl;
	hp = shield = 100;
	coord_x = x;
	coord_y = y;
	damage = 20;
}
void Photon_Cannon::show_status()
{
	std::cout << "Photon Cannon " << std::endl;
	std::cout << " Location : ( " << coord_x << ", " << coord_y << " ) " << std::endl;
	std::cout << " HP : " << hp << std::endl; 
}

int main(void)
{
	Photon_Cannon pc1(3, 3);
	Photon_Cannon pc2(pc1);
	Photon_Cannon pc3 = pc2; // Photon_Canno pc3(pc2);와 동일한 기능

	pc1.show_status();
	pc2.show_status();

	return (0);
}
```
객체 `pc1`을 상수 레퍼런스로 받아 복사 생성한다. 이때 `const`로 받아 `pc`값 자체를 변경할 수 없도록 한다. 먼저 `pc1`이 생성자 오버로딩 되어 생성되었고, `pc2`는 복사 생성자가 호출되었다. 복사 생성자는 오직 '생성'시에 호출된다.

__디폴트 복사 생성자(Default copy constructor)__는 default constructor와 default destructor와 달리 실제로 '복사'를 해준다.

```c++
/* default copy constructor의 한계 */
#include <iostream>
#include <string.h>

class Photon_Cannon
{
	int hp, shield;
	int coord_x, coord_y;
	int damage;
	char *name;

	public:
		Photon_Cannon(int x, int y);
		Photon_Cannon(int x, int y, const char *cannon_name);
		~Photon_Cannon();

		void show_status();
};
Photon_Cannon::Photon_Cannon(int x, int y)
{
	hp = shield = 100;
	coord_x = x;
	coord_y = y;
	damage = 20;
	name = NULL;
}
Photon_Cannon::Photon_Cannon(int x, int y, const char *cannon_name)
{
	hp = shield = 100;
	coord_x = x;
	coord_y = y;
	damage = 20;
	
	name = new char[strlen(cannon_name) + 1];
	strcpy(name, cannon_name);
}
Photon_Cannon::~Photon_Cannon()
{
	if (name)
		delete[] name;
}
void Photon_Cannon::show_status()
{
	std::cout << "Photon Cannon : " << name << std::endl;
	std::cout << " Location : ( " << coord_x << ", " << coord_y << " ) " << std::endl;
	std::cout << " HP : " << hp << std::endl; 
}

int main(void)
{
	Photon_Cannon pc1(3, 3, "halee");
	Photon_Cannon pc2 = pc1;

	pc1.show_status();
	pc2.show_status();

	return (0);
}
```
```text
<result>
Photon Cannon : halee
 Location : ( 3, 3 ) 
 HP : 100
Photon Cannon : halee
 Location : ( 3, 3 ) 
 HP : 100
free(): double free detected in tcache 2
zsh: IOT instruction (core dumped)  ./a.out
```
default copy constructor를 사용하였더니 double free가 난다. 이는 default copy constructor가 얕은 복사밖에 못 하기 때문이다. 이를 방지하기 위해서는 name과 같이 `new`로 새로운 공간을 할당받는 변수가 있는 경우, 이름은 복사하는 대신 공간을 새로 할당하는 복사 생성자를 따로 생성해줘야 한다.

# 소멸자 (destructor)

```c++
#include <iostream>
#include <iostream>

class Test
{
	char c;

	public:
		Test(char _c)
		{
			c = _c;
			std::cout << "Called constructor " << c << std::endl;
		}
		~Test() { std::cout << "Called destructor " << c << std::endl; }
};

void simple_function() { Test b('b'); }

int main(void)
{
	Test a('a');
	simple_function();
	return (0);
}
```
```text
<result>
Called constructor a
Called constructor b
Called destructor b
Called destructor a
```
객체 b는 `simple_function`의 지역 객체 이므로 `main`의 지역 객체인 a보다 먼저 소멸된다.

default constructor와 마찬가지로 default destructor도 존재한다. 다만, default destructor는 아무런 작업도 수행하지 않는다.

### reference
[씹어먹는 C++ - <4 - 1. 이 세상은 객체로 이루어져 있다>](https://modoocode.com/172)

[씹어먹는 C++ - <4 - 2. 클래스의 세계로 오신 것을 환영합니다. (함수의 오버로딩, 생성자)>](https://modoocode.com/173)

[씹어먹는 C++ - <4 - 3. 스타크래프트를 만들자 ① (복사 생성자, 소멸자)>](https://modoocode.com/188)