# 오버로딩 (function overloading)
```c++
#include <iostream>

void print(int x) { std::cout << "int: " << x << std::endl; }
void print(char x) { std::cout << "char: " << x << std::endl; }
void print(double x) { std::cout << "double: " << x << std::endl; }

int main(void)
{
	int a = 1;
	char b = 'c';
	double c = 3.2f;

	print(a);
	print(b);
	print(c);

	return (0);
}
```
```text
<result>
int: 1
char: c
double: 3.2
```
C++에서는 C에서와 달리 같은 이름을 가진 함수가 여러개 존재한다. 구분은 함수를 호출하였을 때 사용하는 인자로 구분을 한다. C++에서는 컴파일러가 알아서 적합한 인자를 가지는 함수를 찾아서 호출한다.

C++ 컴파일러에서 함수를 오버로딩하는 과정은 다음과 같다.

먼저 자신과 타입이 같은 함수를 찾는다. 없다면, 형변환을 통해서 찾는다. 이때 같은 단계에서 두 개 이상이 일치하는 경우 모호하다 (ambiguous)라고 판단하고 오류를 뱉는다.

# 생성자 (constructor)
__생성 후 초기화__를 도와준다.
생성자는 다음과 같은 형태로 정의한다.
```text
클래스 이름 (인자) {}
(객체를 초기화하기 때문에 리턴값이 없다.)
```

```c++
Date day(2011, 3, 1);
Date day = Date(2011, 3, 1);
```
`Date`클래스의 `day` 객체를 만들면서 생성자 `Date(int year, int month, int day)`를 호출하라는 의미이다. 위는 암시적 방법, 아래는 명시적 방법.

# 디폴트 생성자 (default constructor)

```c++
int main(void)
{
	Date day = Date();
	Date day2;
	
	Date day3(); // dafault constructor를 사용하여 초기화하는 것이 아니라 리턴값이 `Date`이고 인자가 없는 함수  `day3`를 정의하게 된 것이다.

	return (0);
}
```

생성자를 정의하지 않았을 때 컴파일러는 자동으로 디폴트 생성자를 추가한다. 생성자를 정의한다면 컴파일러는 디폴트 생성자를 자동으로 추가해주지 않는다. 추가적으로 디폴트 생성자를 직접 정의할 수도 있다.

`day`와 `day2` 둘 다 dafault constructor를 이용하여 객체를 추가하게 된다.

# 생성자 오버로딩

생성자 역시 함수이기 때문에 오버로딩이 가능하다.